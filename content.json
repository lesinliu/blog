{"pages":[{"title":"测试博客","text":"测试测试测试 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2.html"},{"title":"关于","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"JS中的拷贝","text":"基本数据类型 number， string， boolean, undefined, null js中基本数据类型保存着栈内存中,所有的拷贝都是在栈中复制一个副本 var a = 1; var b = a; b = 3; console.log(a); // 1 console.log(b); // 3 ###引用类型 数组（array） 对象 (object) 引用类型中浅拷贝复制的是堆地址，故拷贝值于原值公用同一块堆内存，彼此修改会影响彼此。所以我们在对象拷贝往往期望的的是深拷贝 通过JSON.parse(JSON.stringfy(object))进行深拷贝 （会重置constructor为object,只能解析json数据，function,regexp不行） 对于元素为基本类型数组来说可以通过循环挨个拷贝，也可以通过slice或者concat方法来获得深拷贝对象，这两个方法不操作原数组。const arr = [1,2,3]; const copyArr = arr.slice(0); copyArr[0] = 'a'; // arr [1,2,3] // copyArr ['a',2,3] 循环递归拷贝function deepCopy(obj) { var result = Array.isArray(obj) ? [] : {}; for (var key in obj) { if (obj.hasOwnProperty(key)) { if (typeof obj[key] === 'object') { result[key] = deepCopy(obj[key]); //递归复制 } else { result[key] = obj[key]; } } } return result; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/16/JS%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D/"},{"title":"JS中的for","text":"JS中的for for 语句用于创建一个循环，它包含了三个可选的表达式，三个可选的表达式包围在圆括号中并由分号分隔， 后跟一个在循环中执行的语句（通常是一个块语句）。 for ([initialization]; [condition]; [final-expression]) statement initialization 一个表达式 (包含赋值语句) 或者变量声明。典型地被用于初始化一个计数器。该表达式可以使用var或let关键字声明新的变量，使用var声明的变量不是该循环的局部变量，而是与for循环处在同样的作用域中。用let声明的变量是语句的局部变量。该表达式的结果无意义。 condition 一个条件表达式被用于确定每一次循环是否能被执行。如果该表达式的结果为true， statement 将被执行。 这个表达式是可选的。如果被忽略，那么就被认为永远为真。如果计算结果为假，那么执行流程将被跳到for语句结构后面的第一条语句。 final-expression 每次循环的最后都要执行的表达式。执行时机是在下一次condition的计算之前。通常被用于更新或者递增计数器变量。 statement 只要condition的结果为true就会被执行的语句。 要在循环体内执行多条语句，使用一个块语句（{ … }）来包含要执行的语句。没有任何语句要执行，使用一个空语句（;）。 js中的for in for…in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。 for (variable in object) {...} // variable 在每次迭代时，将不同的属性名分配给变量。 // object 被迭代枚举其属性的对象。 for…in不应该用于迭代一个 Array，其中索引顺序很重要。数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。 js中的for of for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 for (variable of iterable) { //statements } // variable 在每次迭代中，将不同属性的值分配给变量。 // iterable 被迭代枚举其属性的对象。 for…in 语句以原始插入顺序迭代对象的可枚举属性。for…of 语句遍历可迭代对象定义要迭代的数据。 forEach forEach() 方法对数组的每个元素执行一次提供的函数。return undefined arr.forEach(callback[, thisArg]); callback 为数组中每个元素执行的函数，该函数接收三个参数： currentValue:数组中正在处理的当前元素。 index:索引(可选) array:forEach() 方法正在操作的数组。（可选） thisArg 可选参数。当执行回调函数时用作 this 的值(参考对象)。 forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。forEach不直接改变调用它的对象，但是对象可能会被callback改变。）没有办法中止或者跳出 forEach() 循环，除了抛出一个异常。 MDN 笔记 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/18/JS%E4%B8%AD%E7%9A%84for/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 写好blog后$ hexo clean$ hexo g$ hexo d document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/21/hello-world/"},{"title":"js中的valueOf和toString","text":"js中的valueOf和toString null 和 undefined 没有这两个方法；隐式自动类型转换时会自动调用；涉及到操作符的问题，valueOf的优先级比toString的优先级高，涉及到显示问题，toString方法优先级比valueOf方法高。 valueOf valueOf方法返回指定对象的原始值，大多情况下都无需手动调用该方法，js会自动调用。但是复合对象大多数情况无法真正表示一个原始值，此时valueOf方法返回对象本身。该方法会被object后面对象继承，并且每个核心对象都会覆盖该方法。以返回合适的值来使用。 对象 valueOf返回值 Array 数组对象本身 Boolean 布尔值 Date 时间戳 Function 函数本身 Number 数字 Object 对象本身（默认设置） String 字符串 Math 和 Error 对象没有 valueOf 方法。 toString 返回对象的字面量表示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/22/js%E4%B8%AD%E7%9A%84valueOf%E5%92%8CtoString/"},{"title":"html5语义化","text":"html5使用语义化标签的好处： 更好的页面展示（无css样式加载时也能清晰的展示网页结构）。 更利于开发维护（div+id/class才能抵得上一个header标签）。 有利于SEO 无障碍阅读 目前国内使用语义化标签最大作用是 开发者自己看着舒服🤪 当前严格遵守语义化标签的网站 找了半天一个没找到 语义化代码和div代码对比 一段不使用html5语义化标签的代码 &lt;div id=\"header\"&gt;...&lt;/div&gt; &lt;div id=\"main\"&gt; &lt;div id=\"nav\"&gt;...&lt;/div&gt; &lt;div class=\"article\"&gt; &lt;/div&gt; &lt;div id=\"side-bar\"&gt;...&lt;/div&gt; &lt;/div&gt; &lt;div id=\"aside\"&gt;...&lt;/div&gt; &lt;div id=\"footer\"&gt;...&lt;/div&gt; 使用语义化标签的代码 &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;aside&gt;&lt;/aside&gt; &lt;footer&gt;&lt;/footer&gt; 常用的语义化标签及基本使用 规范 规范 规范 // 结构标签 &lt;header&gt;&lt;/header&gt; // 标签定义文档的页眉（介绍信息） 可使用多个 HTML5 的规定&lt;header&gt;都应包含某个级别的标题 &lt;main&gt;&lt;/main&gt; // 文档的主要内容 元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。 在一个文档中，不能出现一个以上的 &lt;main&gt; 元素。&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。 &lt;nav&gt;&lt;/nav&gt; // 标签定义导航链接的部分。 比如分页，或者顶部导航 &lt;article&gt;&lt;/article&gt;// 报纸文章 论坛帖子 博客条目 用户评论。。。 等一个独立的自包含内容 内部可使用header &lt;section&gt;&lt;/section&gt;// 文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。实际开发中基本当div用了 &lt;aside&gt;&lt;/aside&gt; // 标签定义其所处内容之外的内容 side 的内容应该与附近的内容相关。 &lt;footer&gt;&lt;/footer&gt; // 文档中的页脚部分 页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。可使用多个 每个标签都有一定的使用规范。 参考 《HTML5与CSS3权威指南》陆凌牛 w3school 雨落的blog document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/13/html5%E8%AF%AD%E4%B9%89%E5%8C%96/"},{"title":"从输入网址到展示界面浏览器经历了什么?","text":"URL==&gt;页面 地址栏输入网址,回车,浏览器会开启一个线程分析URL,确定是http还是https,然后调用浏览器引擎中的方法加载url(如webview中的loadUrl) 通过dns解析域名获取到IP,然后向该IP发送get请求(携带cookies, userAgent等信息) http会话,浏览器发送报文到服务器, 服务器处理报文(处理逻辑以及读取数据库)并返回响应报文,通过标记对比浏览器是否有缓存,有=&gt;304,无=&gt;200+对应内容 浏览器下载内容, 304时从本地缓存读取 浏览器解析下载的html构建DOM,加载css,js…等,设置缓存 页面结合CSS规则解析渲染DOM,并根据JS操作DOM,读取缓存,执行事件,展示最终页面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/23/%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%B1%95%E7%A4%BA%E7%95%8C%E9%9D%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"},{"title":"测试博客","text":"测试测试测试 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/21/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/"},{"title":"插入图片测试","text":"汗汗汗 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/21/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"MDN","slug":"MDN","link":"/tags/MDN/"},{"name":"JS MDN","slug":"JS-MDN","link":"/tags/JS-MDN/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"JS 浏览器","slug":"JS-浏览器","link":"/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"test","slug":"test","link":"/tags/test/"}],"categories":[{"name":"html","slug":"html","link":"/categories/html/"}]}