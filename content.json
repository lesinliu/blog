{"pages":[{"title":"关于","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"},{"title":"测试博客","text":"测试测试测试 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2.html"}],"posts":[{"title":"JS数据类型及判断类型常用方法","text":"数据类型最新的ES规范定义了八种数据类型 原始类型 String Number Boolean Undefined Null BigInt Symbol 引用类型 Object BigInt和SymbolBigInt BigInt类型是 JavaScript 中的一个基础的数值类型，可以用任意精度表示整数。也就是范围更大的整数。 以前我们表示超出范围的整数通常用String。 普通的Number类型采用64位浮点格式表示，范围 -(2^53-1) —— 2^53-1 Number.MAX_VALUE , Number.MIN_VALUE。 创建BigInt 直接用数字后加n eg: 2n 构造函数 eg: BigInt(‘2’) 基本使用// Number类型 console.log(2 ** 10000) // Infinity // BigInt类型 console.log(2n ** 10000n) // 199506...很长很长...9376n // Number类型和BigInt类型不能互换 console.log(2n ** 100) // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions 总结可以对BigInt使用运算符+、*、-、**和%，就像对数字一样。BigInt 严格来说并不等于一个数字，但它是松散的。在将BigInt转换为Boolean时，它的行为类似于一个数字：if、||、&amp;&amp;、Boolean 和!。BigInt不能与数字互换操作。否则，将抛出TypeError。 Symbol 数据类型 “symbol” 是一种原始数据类型，该类型的性质在于这个类型的值可以用来创建匿名的对象属性。它具有唯一和不可枚举的特性。 声明方法 Symbol 值通过Symbol函数生成`javascript let symbolA = Symbol(); let symbolC = Symbol(‘ss’); // 里面加上’ss‘利于区分 // 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 let sss = new Symbol() // Symbol is not a constructor 报错 不能new调用 Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 摘自阮一峰《ECMAScript 6 入门》 ``` 唯一不重复 let symbolA = Symbol(); let symbolB = Symbol(); console.log(symbolA === symbolB) // false let symbolC = Symbol('ss'); let symbolD = Symbol('ss'); console.log(symbolC === symbolD) // false 匿名隐藏性Symbol属性不可枚举，故在Object.keys(obj)、 for…in、 for…of, Object.getOwnPropertyNames(), JSON.stringify()不会出现。let symbolA = Symbol(); let obj = {} obj[symbolA] = 'hhh' // Symbol 值作为对象属性名时，不能用点运算符。 console.log(obj) // {Symbol(): \"hhh\"} Object.keys(obj) // [] 常用方法 Symbol.prototype.description 获得Symbol的描述 Object.getOwnPropertySymbols() 获取指定对象的所有Symbol属性名 Reflect.ownKeys(obj) 获取obj的所有属性名 包含Symbol Symbol.for() 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局 Symbol.keyFor() 返回一个已登记的 Symbol 类型值的key // Symbol.prototype.description const s = Symbol('ssss'); s.description // ssss let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); s1 === s2 // true let s1 = Symbol.for(\"foo\"); Symbol.keyFor(s1) // \"foo\" let s2 = Symbol(\"foo\"); // Symbol方法创建的Symbol并不会登记到全局 故使用keyFor获取不到key Symbol.keyFor(s2) // undefined // 即使是在局部作用域也会注册到全局 Symbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。 function foo() { return Symbol.for('bar'); } const x = foo(); const y = Symbol.for('bar'); console.log(x === y); // true 类型判断 typeof instanceof Object.prototype.toString.call typeof能判断出基本类型，但是不能识别null和数组 都为object typeof将所有非function引用类型和null都作为object console.log(typeof 1) // number console.log(typeof 'abc')// string console.log(typeof true) // boolean console.log(typeof Symbol())// symbol console.log(typeof null) // object console.log(typeof undefined) // undefined console.log(typeof (()=&gt;{})) // function console.log(typeof new RegExp()) // object instanceof 不能识别基础类型 A instanceof B 判断B是否是A的原型链上。 console.log([] instanceof Array) // true console.log([] instanceof Object) // true Object.prototype.toString.call 比较完美的判断类型的方法 // 基本类型的判断 Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call('aaa') ; // [object String] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] // 引用类型以及内置对象判断 Object.prototype.toString.call(function(){}) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call(new Array()) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(new Map()); // [object Map] Object.prototype.toString.call(new Set()); // [object Set] Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 // 节点类型 Object.prototype.toString.call(document) ; // [object HTMLDocument] 可忽略：其他判断类型方法 constructor 但是constructor指向能轻易被改变，故不安全 参考 阮一峰《ECMAScript 6 入门》 MDN document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/12/27/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"html5语义化","text":"html5使用语义化标签的好处： 更好的页面展示（无css样式加载时也能清晰的展示网页结构）。 更利于开发维护（div+id/class才能抵得上一个header标签）。 有利于SEO 无障碍阅读 目前国内使用语义化标签最大作用是 开发者自己看着舒服🤪 当前严格遵守语义化标签的网站 找了半天一个没找到 语义化代码和div代码对比 一段不使用html5语义化标签的代码 &lt;div id=\"header\"&gt;...&lt;/div&gt; &lt;div id=\"main\"&gt; &lt;div id=\"nav\"&gt;...&lt;/div&gt; &lt;div class=\"article\"&gt; &lt;/div&gt; &lt;div id=\"side-bar\"&gt;...&lt;/div&gt; &lt;/div&gt; &lt;div id=\"aside\"&gt;...&lt;/div&gt; &lt;div id=\"footer\"&gt;...&lt;/div&gt; 使用语义化标签的代码 &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;aside&gt;&lt;/aside&gt; &lt;footer&gt;&lt;/footer&gt; 常用的语义化标签及基本使用 规范 规范 规范 // 结构标签 &lt;header&gt;&lt;/header&gt; // 标签定义文档的页眉（介绍信息） 可使用多个 HTML5 的规定&lt;header&gt;都应包含某个级别的标题 &lt;main&gt;&lt;/main&gt; // 文档的主要内容 元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。 在一个文档中，不能出现一个以上的 &lt;main&gt; 元素。&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。 &lt;nav&gt;&lt;/nav&gt; // 标签定义导航链接的部分。 比如分页，或者顶部导航 &lt;article&gt;&lt;/article&gt;// 报纸文章 论坛帖子 博客条目 用户评论。。。 等一个独立的自包含内容 内部可使用header &lt;section&gt;&lt;/section&gt;// 文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。实际开发中基本当div用了 &lt;aside&gt;&lt;/aside&gt; // 标签定义其所处内容之外的内容 side 的内容应该与附近的内容相关。 &lt;footer&gt;&lt;/footer&gt; // 文档中的页脚部分 页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。可使用多个 每个标签都有一定的使用规范。 参考 《HTML5与CSS3权威指南》陆凌牛 w3school 雨落的blog document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/13/html5%E8%AF%AD%E4%B9%89%E5%8C%96/"},{"title":"JS中的for","text":"JS中的for for 语句用于创建一个循环，它包含了三个可选的表达式，三个可选的表达式包围在圆括号中并由分号分隔， 后跟一个在循环中执行的语句（通常是一个块语句）。 for ([initialization]; [condition]; [final-expression]) statement initialization 一个表达式 (包含赋值语句) 或者变量声明。典型地被用于初始化一个计数器。该表达式可以使用var或let关键字声明新的变量，使用var声明的变量不是该循环的局部变量，而是与for循环处在同样的作用域中。用let声明的变量是语句的局部变量。该表达式的结果无意义。 condition 一个条件表达式被用于确定每一次循环是否能被执行。如果该表达式的结果为true， statement 将被执行。 这个表达式是可选的。如果被忽略，那么就被认为永远为真。如果计算结果为假，那么执行流程将被跳到for语句结构后面的第一条语句。 final-expression 每次循环的最后都要执行的表达式。执行时机是在下一次condition的计算之前。通常被用于更新或者递增计数器变量。 statement 只要condition的结果为true就会被执行的语句。 要在循环体内执行多条语句，使用一个块语句（{ … }）来包含要执行的语句。没有任何语句要执行，使用一个空语句（;）。 js中的for in for…in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。 for (variable in object) {...} // variable 在每次迭代时，将不同的属性名分配给变量。 // object 被迭代枚举其属性的对象。 for…in不应该用于迭代一个 Array，其中索引顺序很重要。数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。 js中的for of for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 for (variable of iterable) { //statements } // variable 在每次迭代中，将不同属性的值分配给变量。 // iterable 被迭代枚举其属性的对象。 for…in 语句以原始插入顺序迭代对象的可枚举属性。for…of 语句遍历可迭代对象定义要迭代的数据。 forEach forEach() 方法对数组的每个元素执行一次提供的函数。return undefined arr.forEach(callback[, thisArg]); callback 为数组中每个元素执行的函数，该函数接收三个参数： currentValue:数组中正在处理的当前元素。 index:索引(可选) array:forEach() 方法正在操作的数组。（可选） thisArg 可选参数。当执行回调函数时用作 this 的值(参考对象)。 forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。forEach不直接改变调用它的对象，但是对象可能会被callback改变。）没有办法中止或者跳出 forEach() 循环，除了抛出一个异常。 MDN 笔记 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/18/JS%E4%B8%AD%E7%9A%84for/"},{"title":"分不清的数组方法slice和splice","text":"容易混淆的 slice splice split 项目中经常会用到slice和splice,当时查下文档用下，隔段时间记忆总会模糊。自己总结下备忘 Array.slice(begin, end) 截取[begin]—end元素作为一个新数组返回。此处的截取是一种浅拷贝。 原始数组并不会改变 begin 可选参数 切片开始位置索引 省略begin表示从0开始；begin为负数表示从数组尾部开始， 若begin &gt; end return [] end 可选参数 切片结束位置索引 省略end表示截取到尾部；end为负数表示从数组尾部开始数， 若end大于数组长度=== 截取到尾部 原始数据元素 const arr = [1,2,3,'a','b']; const newArr = arr.slice(2,3); console.log(newArr) // [ 3 ] 对象元素 由于是浅拷贝 修改了新数组内对象元素属性会影响到原数组 const arr2 = [1,2, {name: '张三'}, {name: '李四'}] const newArr2 = arr2.slice(2,3); console.log(newArr2); // [ { name: '张三' } ] newArr2[0].name = '王五'; console.log(newArr2); // [ { name: '王五' } ] console.log(arr2) // [ 1, 2, { name: '王五' }, { name: '李四' } ] Array.splice(begin[, delCount, ‘新元素…’]) 删除、替换、新增来修改数组，返回被删除元素组成的数组||[] begin 必选 指定修改的位置，为负则从尾部开始指定位置，超出则取最大， delCount 可选 删除元素的个数 为负则不删除；省略了则删除指定位置后所有（arr3.splice(1);） 被插入元素也是可选 const arr3 = [1,2,3,4]; let spliceReturn = arr3.splice(1,0,'a'); console.log(spliceReturn) // [2] console.log(arr3) // [ 1, 'a', 3, 4 ] 注意 split(分隔符[，返回数组的长度])是字符串分割的方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/27/%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95slice%E5%92%8Csplice/"},{"title":"JS中的拷贝","text":"基本数据类型 number， string， boolean, undefined, null js中基本数据类型保存着栈内存中,所有的拷贝都是在栈中复制一个副本 var a = 1; var b = a; b = 3; console.log(a); // 1 console.log(b); // 3 ###引用类型 数组（array） 对象 (object) 引用类型中浅拷贝复制的是堆地址，故拷贝值于原值公用同一块堆内存，彼此修改会影响彼此。所以我们在对象拷贝往往期望的的是深拷贝 通过JSON.parse(JSON.stringfy(object))进行深拷贝 （会重置constructor为object,只能解析json数据，function,regexp不行） 对于元素为基本类型数组来说可以通过循环挨个拷贝，也可以通过slice或者concat方法来获得深拷贝对象，这两个方法不操作原数组。const arr = [1,2,3]; const copyArr = arr.slice(0); copyArr[0] = 'a'; // arr [1,2,3] // copyArr ['a',2,3] 循环递归拷贝function deepCopy(obj) { var result = Array.isArray(obj) ? [] : {}; for (var key in obj) { if (obj.hasOwnProperty(key)) { if (typeof obj[key] === 'object') { result[key] = deepCopy(obj[key]); //递归复制 } else { result[key] = obj[key]; } } } return result; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/16/JS%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D/"},{"title":"插入图片测试","text":"汗汗汗 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/21/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 写好blog后$ hexo clean$ hexo g$ hexo d document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/21/hello-world/"},{"title":"从输入网址到展示界面浏览器经历了什么?","text":"URL==&gt;页面 地址栏输入网址,回车,浏览器会开启一个线程分析URL,确定是http还是https,然后调用浏览器引擎中的方法加载url(如webview中的loadUrl) 通过dns解析域名获取到IP,然后向该IP发送get请求(携带cookies, userAgent等信息) http会话,浏览器发送报文到服务器, 服务器处理报文(处理逻辑以及读取数据库)并返回响应报文,通过标记对比浏览器是否有缓存,有=&gt;304,无=&gt;200+对应内容 浏览器下载内容, 304时从本地缓存读取 浏览器解析下载的html构建DOM,加载css,js…等,设置缓存 页面结合CSS规则解析渲染DOM,并根据JS操作DOM,读取缓存,执行事件,展示最终页面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/23/%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%B1%95%E7%A4%BA%E7%95%8C%E9%9D%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"},{"title":"测试博客","text":"测试测试测试 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/10/21/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/"},{"title":"js中的valueOf和toString","text":"js中的valueOf和toString null 和 undefined 没有这两个方法；隐式自动类型转换时会自动调用；涉及到操作符的问题，valueOf的优先级比toString的优先级高，涉及到显示问题，toString方法优先级比valueOf方法高。 valueOf valueOf方法返回指定对象的原始值，大多情况下都无需手动调用该方法，js会自动调用。但是复合对象大多数情况无法真正表示一个原始值，此时valueOf方法返回对象本身。该方法会被object后面对象继承，并且每个核心对象都会覆盖该方法。以返回合适的值来使用。 对象 valueOf返回值 Array 数组对象本身 Boolean 布尔值 Date 时间戳 Function 函数本身 Number 数字 Object 对象本身（默认设置） String 字符串 Math 和 Error 对象没有 valueOf 方法。 toString 返回对象的字面量表示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/11/22/js%E4%B8%AD%E7%9A%84valueOf%E5%92%8CtoString/"},{"title":"javascript中this的指向问题","text":"this是当前执行代码的环境对象，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值 this指向 全局环境指向全局对象 函数环境 函数调用 非严格模式下指向全局对象， 严格模式下指向undefined 作为对象的方法调用，则this指向该对象 构造函数this被绑定到正在构造的新对象 全局环境（在函数体外部）下（无论是否是严格模式）均指向全局对象。 console.log(this === window) // true 浏览器环境下 其实还有个globalThis表示通用的全局对象 函数环境，要看调用方式来判断this指向 简单的函数调用 非严格模式下指向全局对象， 严格模式下指向undefined // 函数声明 function fn(){ console.log(this === window) // true 浏览器环境 } fn() // 函数表达式 let fnA = function(){ console.log(this === window) // true 浏览器环境 } fnA() // 箭头函数 (()=&gt;{console.log(this === window)})() // true 箭头函数内this绑定的是箭头函数父作用域的this 作为对象的方法调用，则this指向该对象let obj = { a: 1, methodA: function(){ console.log(this.a) // 1 } } obj.methodA() 当一个函数用作构造函数时（使用new关键字） this被绑定到正在构造的新对象 function Person() { console.log(this); // node: Person {} 浏览器： {} 它的__proto__是 Person.prototype 故他是Person的一个实例对象 console.log(Person); // node: [Function: Person] console.log(Person.prototype);// node: Person {} 浏览器： 原型{} 它的constructor: Person 都是{}的意思 console.log(this.__proto__ === Object); //false console.log(typeof this); // object console.log(typeof Person); // function console.log(typeof Person.prototype); // object console.log(Object.prototype.toString.call(this)); // [object Object] console.log(Object.prototype.toString.call(Person)); // [object Function] console.log(Object.prototype.toString.call(Person.prototype)); // [object Object] console.log(Person === this); // false console.log(Person.prototype === this); // false console.log(Person.__proto__ === this); // false console.log(Person == this); // false console.log(Person.prototype == this); // false console.log(Person.__proto__ == this); // false } var personOne = new Person(); // new操作符做了什么 // 1. 创建了个空对象 let o = {} // 2. 将this.__proto__ 指向构造函数的prototype // 3. 绑定属性 Person.call(o) 改变Person内部this指向为o // 4. returtn o 结果就是我们在构造函数内打印this会指向对象{}，{} 它的proto是 Person.prototype 故他是Person的一个实例对象Person 当函数被用作事件处理函数时，它的this指向触发事件的元素（一些浏览器在使用非addEventListener的函数动态添加监听函数时不遵守这个约定）。 改变this指向 call apply bind ( ECMAScript 5 引入了 Function.prototype.bind()) call let obj = { a: 'a' } let obj2 = { method2(){ console.log(this.a) // a } } // 调用call将obj2内部this指向obj, call(this, ...args) 可传入多个参数 obj2.method2.call(obj) apply apply和call用法类似，唯一区别就是call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组 bind 创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。与上面两个不同的是bind()返回的是一个绑定了新的this的函数。 参考 MDN document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2016/12/22/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"html","slug":"html","link":"/tags/html/"},{"name":"MDN","slug":"MDN","link":"/tags/MDN/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"JS 浏览器","slug":"JS-浏览器","link":"/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"categories":[{"name":"html","slug":"html","link":"/categories/html/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}]}